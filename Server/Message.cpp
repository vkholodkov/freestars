/*
Copyright 2003 - 2005 Elliott Kleinrock, Dan Neely, Kurt W. Over, Damon Domjan

This file is part of FreeStars, a free clone of the Stars! game.

FreeStars is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

FreeStars is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with FreeStars; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

The full GPL Copyright notice should be in the file COPYING.txt

Contact:
Email Elliott at 9jm0tjj02@sneakemail.com
*/

#include "FSServer.h"

#include "Packet.h"

#if defined(_DEBUG) && defined(DEBUG_NEW)
#define new DEBUG_NEW
#endif

/**
 * @file Message.cpp
 * @ingroup Server
 */
namespace FreeStars {

/**
 * @name remark
 * @remarks {
      - Some messages need to be generated by the client - like the "this planet is green", "that planet is owned by so-and-so", etc. messages because the turn file doesn't have access to the information in the history file.  Actually...most of this information should go in the history file and not here.  But it's useful to get the ideas down - and I'll need to create the appropriate information for them.
      VictoryMsg
      TieMsg
      LossMsg
      EmptyQueue
      TechIncrease
      TechNewPart
      MTPart
      MTTech
      MTShips
      MTErrorCargo  <!-- <MT>  I DEMAND 5000 KILOTONS OF IRONIUM! STOP GIVING ME BORANIUM ALREADY! -->
      MTErrorPart  <!-- You already have that part. -->
      MTErrorShips  <!-- Maybe lump this in under the generic "not enough slots" error. -->
      MTArrived  <!-- A new MT is advertising -->
      MTChangedDirection <!-- The MT has changed course and speed -->
      BattleThisTurn  <!-- You have been in 12 battles this turn... -->
      BattleWin
      BattleLoss
      BattleTie
      BattleComplex  <!-- I can't explain it.  Watch it in the battle viewer instead.  -->
      MineHitEnemy  <!-- An enemy has struck one of this player's minefields. -->
      MineHitFriendly  <!-- If the player has hit a mine. -->
      MineSweptEnemy  <!-- An enemy swept one of this player's minefields. -->
      MineSweptFriendly  <!-- The player has swept a minefield. -->
      MineLayed <!-- [Verify] You've deployed a minefield.  Are mines added to a minefield another message? -->
      FleetDone  <!-- The fleet has completed its orders.  -->
      FleetFuelGenerate <!-- Fleet x has generated y mg of fuel from its ramscoops. -->
      FleetFuelOut <!-- Fleet x has run out of gas.  Call AAA.  -->
      FleetBombed <!-- Your fleet has slaughtered 129800 innocent civilians.  -->
      FleetMerge
      FleetRoute <!-- [Verify] Fleet x has been routed to y. -->
      FleetSend <!-- You've sent a fleet to someone.  -->
        <!-- other player "out of slots" error -->
      FleetReceive <!-- Someone has transferred a fleet to you. -->
        <!-- Generic "out of slots" error -->
      FleetCargo <!-- Fleet w has transferred x ktons/mg of y to z, where z is another fleet or planet. -->
      PlanetBombed <!-- x people have died, y installations, and z defenses -->
      PlanetPacketed <!-- You've been hit by a big rock that did this much damage.  -->
      PacketInbound <!-- A packet you can't catch is boring in fast! -->
      PlayerMsg  <!-- Ignore other players transmissions.  -->
      PopLossPlanetVal <!-- You've lost colonists because it's a communist...err...red planet. -->
      PopLossCrowding <!-- Time to renovate the slums on that planet - you've got too many people for its value.  -->
      PlanetColonized  <!-- You've put your flag on this planet. -->
      EventTech  <!-- You've discovered an artifact.  -->
      EventTerra <!-- Fundamental changes have changed a random variable some amount.  Hm.  If fundamental changes have merely cancelled production, maybe don't include the variable changed and have the amount be -1 or something. -->
      EventMineralIncrease <!-- You've gotten lucky and discovered more minerals -->
      EventComet <!-- You've been smacked by a comet.  Seperate entries for all possible sizes? E.g. EventCometHuge, EventCometSmall? -->
      BuiltFactory
      BuiltMine
      BuiltDefense
      BuiltShip
      BuiltAlchemy
      BuiltPlanetaryScanner
      TerraInsta <!-- AKA Instaforming.  For the CAs in the house.  -->
      TerraBuilt <!-- Terra completed by building it in the queue.  -->
      TerraRemote <!-- From Orbital Adjusters (and maybe terra bombs?  Verify the latter) -->
      TerraPermanent <!-- Permanent terraforming for the CAs.  -->
      TerraPacket <!-- "Normal" terraforming from packeting a planet. -->
      TerraPacketPermanent <!-- "Deep" terraforming from packeting a planet. -->
        <!-- Double check messages given when packet terra occurs.  -->
 *}
 */

Message::~Message()
{
	for (unsigned int i = 0; i < mItems.size(); ++i) {
		delete mItems[i];
	}

	mItems.erase(mItems.begin(), mItems.end());
}

MessItem::~MessItem()
{
}

void MessItem::AddDesc(TiXmlElement * node) const
{
	if (node != NULL && !mDesc.empty())
		node->SetAttribute("Description", mDesc.c_str());
}

string MessItem::ToString() const
{
	string m;
	if (!mDesc.empty()) {
		m = "Desc: ";
		m += mDesc;
		m += " ";
	}

	return m;
}

MessItem * MessItem::ParseNode(const TiXmlNode * node)
{
	if (node == NULL)
		return NULL;

	MessItem * mi;
	if (stricmp(node->Value(), "Player") == 0)
		mi = MessPlayer::ParseNode(node);
	else if (stricmp(node->Value(), "Number") == 0)
		mi = MessNumber::ParseNode(node);
	else if (stricmp(node->Value(), "Float") == 0)
		mi = MessFloat::ParseNode(node);
	else if (stricmp(node->Value(), "String") == 0)
		mi = MessString::ParseNode(node);
	else
		mi = MessLoc::ParseNode(node);

	if (mi != NULL) {
		const TiXmlElement * tie = node->ToElement();
		if (tie != NULL && tie->Attribute("Description"))
			mi->mDesc = tie->Attribute("Description");
	}

	return mi;
}

MessLoc::~MessLoc()
{
	if (mDWD)
		delete mLoc;
}

void MessLoc::WriteNode(TiXmlNode * node) const
{
	const Planet * planet = dynamic_cast<const Planet *>(mLoc);
	if (planet != NULL) {
		TiXmlElement * pNode = new TiXmlElement("Planet");
		AddDesc(pNode);
		pNode->SetAttribute("IDNumber", planet->GetID());
		AddString(pNode, "Name", planet->GetName().c_str());
		node->LinkEndChild(pNode);
		return;
	}

	const Fleet * fleet = dynamic_cast<const Fleet *>(mLoc);
	if (fleet != NULL) {
		TiXmlElement * fNode = new TiXmlElement("Fleet");
		AddDesc(fNode);
		fNode->SetAttribute("IDNumber", fleet->GetID());
		AddLong(fNode, "Owner", fleet->GetOwner()->GetID());
		if (fleet->IsEmpty())
			fleet->WriteLocation(fNode);
		node->LinkEndChild(fNode);
		return;
	}

	const Packet * packet = dynamic_cast<const Packet *>(mLoc);
	if (packet != NULL) {
		TiXmlElement * pNode = new TiXmlElement("Packet");
		AddDesc(pNode);
		pNode->SetAttribute("IDNumber", packet->GetID());
		if (packet->IsEmpty())
			packet->WriteLocation(pNode);
		node->LinkEndChild(pNode);
		return;
	}

	const MineField * minef = dynamic_cast<const MineField *>(mLoc);
	if (minef != NULL) {
		TiXmlElement * mNode = new TiXmlElement("MineField");
		AddDesc(mNode);
		mNode->SetAttribute("IDNumber", minef->GetID());
		if (minef->IsEmpty())
			minef->WriteLocation(mNode);
		node->LinkEndChild(mNode);
		return;
	}

	const Salvage * scrap = dynamic_cast<const Salvage *>(mLoc);
	if (scrap != NULL) {
		TiXmlElement * sNode = new TiXmlElement("Salvage");
		AddDesc(sNode);
		sNode->SetAttribute("IDNumber", scrap->GetID());
		if (scrap->IsEmpty())
			scrap->WriteLocation(sNode);
		node->LinkEndChild(sNode);
		return;
	}

	TiXmlNode * lNode = mLoc->WriteLocation(node);
	AddDesc(lNode->ToElement());
}

MessLoc * MessLoc::ParseNode(const TiXmlNode * node)
{
	MessLoc * mi = NULL;
	const TiXmlElement * tie;
	if (stricmp(node->Value(), "Planet") == 0) {
		tie = node->ToElement();
		if (tie != NULL) {
			int pnum;
			tie->Attribute("IDNumber", &pnum);
			const Planet * p = TheGalaxy->GetPlanet(pnum);
			if (p != NULL)
				mi = new MessLoc("", p);
		}
	} else if (stricmp(node->Value(), "Fleet") == 0) {
		const Player * p = TheGame->GetPlayer(GetLong(node->FirstChild("Owner")));
		if (p != NULL) {
			int fNum;
			tie = node->ToElement();
			if (tie != NULL) {
				tie->Attribute("IDNumber", &fNum);
				const Fleet * f = p->GetFleet(fNum);
				if (f != NULL)
					mi = new MessLoc("", f);
			}
		}
	} else if (stricmp(node->Value(), "Packet") == 0) {
	} else if (stricmp(node->Value(), "MineField") == 0) {
	} else if (stricmp(node->Value(), "Salvage") == 0) {
	} else if (stricmp(node->Value(), "Location") == 0) {
		Location * loc = new Location();
		loc->ParseNode(node);
		mi = new MessLoc("", loc, true);
	}

	return mi;
}

bool MessLoc::StoreMessageLocation(const Location * loc)
{
	if (mLoc != loc)
		return false;

	assert(mDWD == false);
	mLoc = new Location(*loc);
	mDWD = true;
	return true;
}

string MessLoc::ToString() const
{
	string m = MessItem::ToString() + "Location(";
	m += Long2String(mLoc->GetPosX());
	m += ", ";
	m += Long2String(mLoc->GetPosY());
	m += ") : ";
	
	const Planet * planet = dynamic_cast<const Planet *>(mLoc);
	if (planet != NULL)
	{
		m += "Planet-> " + planet->GetName();
		return m;
	}
		
	const Fleet * fleet = dynamic_cast<const Fleet *>(mLoc);
	if (fleet != NULL)
	{
		m += "Fleet-> Owner(";
	 	m += Long2String(fleet->GetOwner()->GetID());
		m += ") IDNumber(";
	 	m += Long2String(fleet->GetID());
		m += ")";
		return m;
	}

	const Packet * packet = dynamic_cast<const Packet *>(mLoc);
	if (packet != NULL)
	{
		m += "Packet-> IDNumber(" ;
	 	m += Long2String(packet->GetID());
		m += ")";
		return m;
	}
		
	const MineField * minef = dynamic_cast<const MineField *>(mLoc);
	if (minef != NULL)
	{
		m += "MneField->";
//		AddLong(mNode, "IDNumber", minef->GetID());
		return m;
	}

	const Salvage * scrap = dynamic_cast<const Salvage *>(mLoc);
	if (scrap != NULL) {
		m += "Salvage-> IDNumber(";
	 	m += Long2String(scrap->GetID());
		m += ")";
		return m;
	}
	
	return m;
}

MessPlayer::~MessPlayer()
{
}

void MessPlayer::WriteNode(TiXmlNode * node) const
{
	AddDesc(AddLong(node, "Player", mPlayer->GetID()));
}

MessPlayer * MessPlayer::ParseNode(const TiXmlNode * node)
{
	const Player * p = TheGame->GetPlayer(GetLong(node));
	if (p != NULL)
		return new MessPlayer("", p);
	else
		return NULL;
}

string MessPlayer::ToString() const
{
	return MessItem::ToString() + string("Player: ") + Long2String(mPlayer->GetID());
}

MessNumber::~MessNumber()
{
}

void MessNumber::WriteNode(TiXmlNode * node) const
{
	AddDesc(AddLong(node, "Number", mNumber));
}

MessNumber * MessNumber::ParseNode(const TiXmlNode * node)
{
	return new MessNumber("", GetLong(node));
}

string MessNumber::ToString() const
{
	return MessItem::ToString() + string("Number: ") + Long2String(mNumber);
}

MessFloat::~MessFloat()
{
}

void MessFloat::WriteNode(TiXmlNode * node) const
{
	AddDesc(AddDouble(node, "Float", mNumber));
}

MessFloat * MessFloat::ParseNode(const TiXmlNode * node)
{
	return new MessFloat("", GetDouble(node));
}

string MessFloat::ToString() const
{
	return MessItem::ToString() + string("Number: ") + Float2String(mNumber);
}

MessString::~MessString()
{
}

void MessString::WriteNode(TiXmlNode * node) const
{
	AddDesc(AddString(node, "String", mStr.c_str()));
}

MessString * MessString::ParseNode(const TiXmlNode * node)
{
	return new MessString("", GetString(node));
}

string MessString::ToString() const
{
	string m = MessItem::ToString() + "String: " + mStr;
	return m;
}

MessXMLNode::~MessXMLNode()
{
}

void MessXMLNode::WriteNode(TiXmlNode * node) const
{
	node->InsertEndChild(*mNode);
}

MessXMLNode * MessXMLNode::ParseNode(const TiXmlNode * node)
{
	return new MessXMLNode(node);
}

string MessXMLNode::ToString() const
{
	string m = MessItem::ToString() + "XML Node: ";
	return m;
}


void Message::AddItem(MessItem * mi)
{
	mItems.push_back(mi);
}

/*
<Message type="type">
	<Planet/>
	<Fleet/>
	<Packet/>
	...
	<Location/>
	<Player/>
	<Number>456</Number>
	<String>String</String>
</Message>
*/
void Message::WriteNode(TiXmlNode * node) const
{
	TiXmlElement * mNode = new TiXmlElement("Message");
	mNode->SetAttribute("Type", mType);

	for (unsigned int i = 0; i < mItems.size(); ++i)
		mItems[i]->WriteNode(mNode);

	node->LinkEndChild(mNode);
}

bool Message::ParseNode(const TiXmlNode * node)
{
	if (node == NULL)
		return false;

	const TiXmlElement * tie = node->ToElement();
	if (tie == NULL)
		return false;

	mType = tie->Attribute("Type");
	if (mType.empty())
		return false;

	const TiXmlNode * child;
	MessItem * mi;
	for (child = node->FirstChild(); child != NULL; child = child->NextSibling()) {
		mi = MessItem::ParseNode(child);
		if (mi != NULL)
			AddItem(mi);
	}

	return true;
}

string Message::ToString() const
{
	string m = "Message (" + mType + ") :";
	for (unsigned int i = 0; i < mItems.size(); ++i)
		m += "\n\t" + mItems[i]->ToString();
		
	return m;
}

void Message::ApplyVisitor(MessageVisitor &visitor) const {
    visitor.VisitMessage(mType);

	for(deque<MessItem *>::const_iterator i = mItems.begin(); i < mItems.end(); ++i) {
		const MessLoc * ml = dynamic_cast<const MessLoc *>(*i);
		if(ml != NULL) {
            visitor.VisitLocation(ml->mDesc, ml->mLoc);
		}

		MessPlayer * mp = dynamic_cast<MessPlayer *>(*i);
		if(mp != NULL) {
            visitor.VisitPlayer(mp->mDesc, mp->mPlayer);
		}

		MessNumber * mn = dynamic_cast<MessNumber *>(*i);
		if(mn != NULL) {
            visitor.VisitNumber(mn->mDesc, mn->mNumber);
		}

		MessFloat * mf = dynamic_cast<MessFloat *>(*i);
		if(mf != NULL) {
            visitor.VisitFloat(mf->mDesc, mf->mNumber);
		}

		MessString * ms = dynamic_cast<MessString *>(*i);
		if(ms != NULL) {
            visitor.VisitString(ms->mDesc, ms->mStr);
		}

		MessXMLNode * mx = dynamic_cast<MessXMLNode *>(*i);
		if(mx != NULL) {
            visitor.VisitXMLNode(mx->mDesc, mx->mNode);
		}
	}
}

void Message::StoreMessageLocation(const Location * loc, const Player * player)
{
	for (int i = 0; i < mItems.size(); ++i) {
		MessLoc * ml = dynamic_cast<MessLoc *>(mItems[i]);
		if (ml != NULL) {
			if (ml->StoreMessageLocation(loc))
				AddItem("Deleted location", dynamic_cast<const Fleet *>(loc)->GetName(player));
		}
	}
}

}
